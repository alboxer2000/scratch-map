<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Map Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            background-color: #ffffff;
            touch-action: none;
            width: 100%;
            height: 100vh;
            display: block;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            width: 30px;
            height: 30px;
            border: none;
            cursor: pointer;
            border-radius: 8px;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 8px;
            border: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .btn {
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #1f2937;
        }
        .category-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .category-btn.active {
            border-color: #1f2937;
            transform: scale(1.1);
        }
        .categories-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .tool-bar {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .tool-btn {
            padding: 12px;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
            background-color: #e5e7eb;
        }
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
        }
        #loadMapBtn, #loadCategoriesBtn {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center">

    <canvas id="mapCanvas"></canvas>

    <div class="controls">
        <div class="control-group">
            <input type="text" id="pointName" placeholder="Point Name" class="p-2 border border-gray-300 rounded-lg">
            <input type="color" id="categoryColorInput" value="#3b82f6">
            <input type="text" id="categoryNameInput" placeholder="Category Name" class="p-2 border border-gray-300 rounded-lg">
            <button id="addCategoryBtn" class="btn btn-primary">Add Category</button>
        </div>
        <div class="categories-container" id="categoryButtons"></div>
    </div>

    <div class="tool-bar">
        <button id="drawToolBtn" class="tool-btn active">Add Point</button>
        <button id="connectToolBtn" class="tool-btn">Connect</button>
        <button id="saveBtn" class="btn btn-primary">Save Map</button>
        <label for="loadMapBtn" class="btn btn-primary text-center">Load Map</label>
        <input type="file" id="loadMapBtn" accept=".json">
        <label for="loadCategoriesBtn" class="btn btn-primary text-center">Load Categories</label>
        <input type="file" id="loadCategoriesBtn" accept=".json">
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const pointNameInput = document.getElementById('pointName');
        const categoryColorInput = document.getElementById('categoryColorInput');
        const categoryNameInput = document.getElementById('categoryNameInput');
        const addCategoryBtn = document.getElementById('addCategoryBtn');
        const categoryButtonsContainer = document.getElementById('categoryButtons');
        const drawToolBtn = document.getElementById('drawToolBtn');
        const connectToolBtn = document.getElementById('connectToolBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadMapInput = document.getElementById('loadMapBtn');
        const loadCategoriesInput = document.getElementById('loadCategoriesBtn');

        const POINT_SIZE = 10;
        const FONT_SIZE = 16;
        const TEXT_SCALE_THRESHOLD = 0.5;

        let mapData = { points: [], lines: [] };
        let categories = [{ name: 'Default', color: '#3b82f6' }];
        let selectedCategoryColor = categories[0].color;
        let lastPointId = 0;
        let tool = 'draw';
        let pointToConnect = null;

        // Pan and Zoom Variables
        let isPanning = false;
        let lastPan = { x: 0, y: 0 };
        let offset = { x: 0, y: 0 };
        let scale = 1.0;

        // Helper function to update category buttons
        function updateCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            categories.forEach(cat => {
                const btn = document.createElement('button');
                btn.className = 'category-btn';
                btn.style.backgroundColor = cat.color;
                btn.dataset.color = cat.color;
                if (cat.color === selectedCategoryColor) {
                    btn.classList.add('active');
                }
                btn.onclick = () => {
                    selectedCategoryColor = cat.color;
                    document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                categoryButtonsContainer.appendChild(btn);
            });
        }

        // Add category event listener
        addCategoryBtn.addEventListener('click', () => {
            const name = categoryNameInput.value.trim();
            const color = categoryColorInput.value;
            if (name && color) {
                categories.push({ name: name, color: color });
                updateCategoryButtons();
                categoryNameInput.value = '';
            }
        });

        // Tool selection
        drawToolBtn.addEventListener('click', () => {
            tool = 'draw';
            drawToolBtn.classList.add('active');
            connectToolBtn.classList.remove('active');
            pointToConnect = null;
        });
        connectToolBtn.addEventListener('click', () => {
            tool = 'connect';
            connectToolBtn.classList.add('active');
            drawToolBtn.classList.remove('active');
        });

        // Canvas events
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function toWorldCoordinates(x, y) {
            return {
                x: (x - offset.x) / scale,
                y: (y - offset.y) / scale
            };
        }

        canvas.addEventListener('click', (e) => {
            const canvasPos = getCanvasCoordinates(e);
            const worldPos = toWorldCoordinates(canvasPos.x, canvasPos.y);
            const pointRadius = (POINT_SIZE + 5) * scale;

            if (tool === 'draw') {
                const newPoint = {
                    id: lastPointId++,
                    x: worldPos.x,
                    y: worldPos.y,
                    color: selectedCategoryColor,
                    text: pointNameInput.value.trim()
                };
                mapData.points.push(newPoint);
                pointNameInput.value = '';
                draw();
            } else if (tool === 'connect') {
                const clickedPoint = mapData.points.find(p => {
                    const dx = (p.x * scale + offset.x) - canvasPos.x;
                    const dy = (p.y * scale + offset.y) - canvasPos.y;
                    return Math.sqrt(dx * dx + dy * dy) < pointRadius;
                });
                
                if (clickedPoint) {
                    if (pointToConnect && pointToConnect.id !== clickedPoint.id) {
                        const line = {
                            from: pointToConnect.id,
                            to: clickedPoint.id,
                            color: pointToConnect.color // Use the color of the first point
                        };
                        mapData.lines.push(line);
                        pointToConnect = null;
                        draw();
                    } else {
                        pointToConnect = clickedPoint;
                    }
                }
            }
        });

        // Save and Load
        saveBtn.addEventListener('click', () => {
            const mapJson = JSON.stringify(mapData);
            const categoriesJson = JSON.stringify(categories);
            
            // Save map file
            const mapBlob = new Blob([mapJson], { type: 'application/json' });
            const mapUrl = URL.createObjectURL(mapBlob);
            const mapA = document.createElement('a');
            mapA.href = mapUrl;
            mapA.download = 'map.json';
            mapA.click();

            // Save categories file
            const categoriesBlob = new Blob([categoriesJson], { type: 'application/json' });
            const categoriesUrl = URL.createObjectURL(categoriesBlob);
            const categoriesA = document.createElement('a');
            categoriesA.href = categoriesUrl;
            categoriesA.download = 'category.json';
            categoriesA.click();
        });

        loadMapInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        mapData = JSON.parse(event.target.result);
                        lastPointId = Math.max(0, ...mapData.points.map(p => p.id)) + 1;
                        draw();
                    } catch (err) {
                        console.error('Error parsing map JSON:', err);
                    }
                };
                reader.readAsText(file);
            }
        });

        loadCategoriesInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        categories = JSON.parse(event.target.result);
                        updateCategoryButtons();
                    } catch (err) {
                        console.error('Error parsing categories JSON:', err);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Pan and Zoom
        canvas.addEventListener('mousedown', (e) => {
            isPanning = true;
            lastPan = getCanvasCoordinates(e);
            canvas.style.cursor = 'grabbing';
        });
        canvas.addEventListener('mouseup', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });
        canvas.addEventListener('mouseout', () => {
            isPanning = false;
            canvas.style.cursor = 'grab';
        });
        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const currentPan = getCanvasCoordinates(e);
                offset.x += (currentPan.x - lastPan.x);
                offset.y += (currentPan.y - lastPan.y);
                lastPan = currentPan;
                draw();
            }
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            const pos = getCanvasCoordinates(e);
            
            const oldScale = scale;
            scale *= (e.deltaY < 0 ? zoomFactor : 1 / zoomFactor);
            scale = Math.max(0.2, Math.min(3, scale));

            offset.x = pos.x - (pos.x - offset.x) * (scale / oldScale);
            offset.y = pos.y - (pos.y - offset.y) * (scale / oldScale);
            draw();
        });

        // Draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (mapData.lines) {
                mapData.lines.forEach(line => {
                    const fromPoint = mapData.points.find(p => p.id === line.from);
                    const toPoint = mapData.points.find(p => p.id === line.to);
                    if (fromPoint && toPoint) {
                        ctx.beginPath();
                        ctx.moveTo(fromPoint.x * scale + offset.x, fromPoint.y * scale + offset.y);
                        ctx.lineTo(toPoint.x * scale + offset.x, toPoint.y * scale + offset.y);
                        ctx.strokeStyle = line.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }

            if (mapData.points) {
                mapData.points.forEach(point => {
                    const pointSize = POINT_SIZE * scale;
                    const canvasX = point.x * scale + offset.x;
                    const canvasY = point.y * scale + offset.y;
                    
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, pointSize, 0, 2 * Math.PI);
                    ctx.fillStyle = point.color;
                    ctx.fill();

                    if (point.text && scale > TEXT_SCALE_THRESHOLD) {
                        ctx.font = `bold ${FONT_SIZE * scale}px Arial`;
                        ctx.fillStyle = '#1f2937';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(point.text, canvasX, canvasY + pointSize + 10);
                    }
                });
            }
        }

        // Initialize
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        window.onload = () => {
            resizeCanvas();
            updateCategoryButtons();
        };
    </script>
</body>
</html>
